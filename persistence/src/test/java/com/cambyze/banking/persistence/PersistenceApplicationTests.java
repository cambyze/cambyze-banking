package com.cambyze.banking.persistence;

import static org.junit.jupiter.api.Assertions.assertTrue;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.Set;
import org.junit.jupiter.api.Test;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import com.cambyze.banking.persistence.dao.BankAccountRepository;
import com.cambyze.banking.persistence.model.Account;
import com.cambyze.banking.persistence.model.Constants;
import com.cambyze.banking.persistence.model.Operation;
import com.cambyze.banking.persistence.services.PersistenceServices;


@SpringBootTest
class PersistenceApplicationTests {

  private static final Logger LOGGER = LoggerFactory.getLogger(PersistenceApplicationTests.class);

  @Autowired
  private BankAccountRepository bankAccountRepository;

  @Autowired
  private PersistenceServices persistenceServices;


  @Test
  void testAccountDao() {
    LOGGER.debug("Test Account DAO");

    LOGGER.debug("Find a non existing BAN");
    Account ba = bankAccountRepository.findByBankAccountNumber("DOES NOT EXIST");
    if (ba == null) {
      LOGGER.debug("The BAN does not exist, it's OK");
    } else {
      LOGGER.debug("The BAN exists !!!" + ba.getId());
    }
    assertTrue(ba == null);

    ba = new Account();
    bankAccountRepository.save(ba);
    LOGGER.debug("New BAN:" + ba.getBankAccountNumber());
    LOGGER.debug("New BA full content:" + ba.toString());
    // the creation of the BAN is done post insertion to have the id generated by Hibernate then we
    // have to save it twice - no time to find a better solution
    // TODO : find a better solution
    bankAccountRepository.save(ba);

    // id > 0 & balance = 0 & no overdraft & every day bank account
    assertTrue(ba.getId() > 0);
    assertTrue(ba.getBankAccountNumber().equals("CAMBYZEBANK-" + ba.getId()));
    assertTrue(ba.getBalanceAmount().equals(BigDecimal.valueOf(0.0)));
    assertTrue(ba.getOverdraftAmount().equals(BigDecimal.valueOf(0.0)));
    assertTrue(ba.getAccountType() == Constants.ACCOUNT_TYPE_BANK);


    // Test the findByBankAccountNumber method
    Account ba2 = bankAccountRepository.findByBankAccountNumber(ba.getBankAccountNumber());
    LOGGER.debug("Verify the found BA full content:" + ba2.toString());
    // Both objects must be equal
    assertTrue(ba2.getId().equals(ba.getId()));
    assertTrue(ba2.getBankAccountNumber().equals(ba.getBankAccountNumber()));
    assertTrue(ba2.getAccountType() == ba.getAccountType());
  }

  @Test
  void testAccountServices() {
    LOGGER.debug("Test Services");
    String ban = persistenceServices.createNewBankAccount();
    LOGGER.debug("New BAN generated by PersistenceServices.createNewBankAccount(): " + ban);
    assertTrue(ban != null && ban.startsWith("CAMBYZEBANK-"));
  }


  @Test
  void testOperationServices() {
    LOGGER.debug("Test Operation Services");

    LOGGER.debug("Test technical error");
    Long opId = persistenceServices.createNewBankingOperation(null, null, 0, null);
    LOGGER.debug("First error with null value then opId:" + opId);
    assertTrue(opId == Constants.INVALID_BANK_ACCOUNT);

    Account ba = null; // Bad idea ;)
    persistenceServices.createNewBankingOperation(ba, LocalDate.now(),
        Constants.OPERATION_TYPE_DEPOSIT, BigDecimal.valueOf(100.0));
    LOGGER.debug("Second error with bank account null then opId:" + opId);
    assertTrue(opId == Constants.INVALID_BANK_ACCOUNT);

    ba = new Account();
    opId = persistenceServices.createNewBankingOperation(ba, LocalDate.now(),
        Constants.OPERATION_TYPE_DEPOSIT, BigDecimal.valueOf(100.0));
    LOGGER.debug("Third error banking account invalid with Operation id: " + opId);
    assertTrue(opId == Constants.INVALID_BANK_ACCOUNT);


    String ban = persistenceServices.createNewBankAccount();
    ba = persistenceServices.findBankAccountByBAN(ban);
    if (ba != null) {
      LOGGER.debug("BAN created for the operation : " + ba.getBankAccountNumber());
      opId = persistenceServices.createNewBankingOperation(ba, LocalDate.now(),
          Constants.OPERATION_TYPE_DEPOSIT, BigDecimal.valueOf(-100.0));
      LOGGER.debug("Error with negative amount : " + opId);
      assertTrue(opId == Constants.INVALID_AMOUNT);

      opId = persistenceServices.createNewBankingOperation(ba, LocalDate.now(),
          Constants.OPERATION_TYPE_DEPOSIT, BigDecimal.valueOf(100.0));
      LOGGER.debug("First success with Operation id: " + opId);
      assertTrue(opId > 0);
      Operation op = persistenceServices.findBankingOperationById(opId);
      LOGGER.debug("First success with Operation : " + op);
      assertTrue(op.getBankAccount().getBankAccountNumber().equals(ba.getBankAccountNumber()));

      opId = persistenceServices.createNewBankingOperation(ba, LocalDate.now(),
          Constants.OPERATION_TYPE_DEPOSIT, BigDecimal.valueOf(1050.36));
      Set<Operation> ops =
          persistenceServices.findBankingOperationsOfBankAccount(ba.getBankAccountNumber());
      LOGGER.debug("List of operations : " + ops);
      assertTrue(!ops.isEmpty());

    } else {
      LOGGER.error("Anormal error banking account null ");
      assertTrue(ba != null);
    }
  }


}
